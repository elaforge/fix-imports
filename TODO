* done; - not done; / decided against


bug:
  - unqualified imports cause imports due to symbols not in call position
  - It wants to manage unqualified imports it shouldn't
    . if I have 'unqualified: Control.Monad.when', it will delete a
      'import Control.Monad (unless)'

feature:
  - Support unqualified imports of constructors, e.g. Data.Either.Either(Right)
  - I could add multiple imports by adding the non-prioritized ones as comments.
    . But this will be annoying in the common case where prioritization works.
      Maybe only for local imports?  Or local imports where there isn't an
      obvious winner, where obvious winner means in the same directory?

  - unqualified syntax sugar: Data.Bifunctor.(first,second)
  groq style:
    - space for qualified
    * import qualified as some other name, e.g.
      . import-as: Data.Text.Lazy as DTL, ...
    - disable automatic grouping, just [hackage, local]

  - add *all* possible imports, but comment out all but the priority one
    . This seems not great because much of the time it guesses right.

  - Use a cabal sandbox if one is present.
  - use stack if present
    . I think just:
      if [ $use_stack ]; then
          export GHC_PACKAGE_PATH=$(stack path --ghc-package-path)
          PATH=$(stack path --compiler-bin):$PATH
      fi

  - haskell-src-exts is buggy.  Can I use the ghc parser yet?
    . ghc-parser package?
    . But I thought this was tied to the trees that grow changes?
    . ghc-syntax-highlighter - uses lexer?

  / Optionally write a cache of the package db.
    . No need, most time is spent in haskell-src-exts parsing.
    . Actually not really, but overall time is low.

  - Use haskell-names to guess the module to import based on the function name:
    http://documentup.com/haskell-suite/haskell-names
    This could even potentially support unqualified imports.

  / Didn't want to import Ui.Types when I already have Types imported
  unqualified.
    I think this is working as intended, because an unqualified import can also
    be used qualified.

  - If the choice is still ambiguous I could ask interactively.
    . This requires deeper integration, but vim does have menu selection
      support.

  - Or write a simple tool to analyze existing code and assign priorities
    based on how often each is imported.
