* done; - not done; / decided against

* I could have hard-coded one-offs for common unqualified imports,
  e.g. (</>) -> System.FilePath ((</>))
  . I'd need to start looking at unqualified symbols, and then I need to know
    if they are in scope or not.
  . Get non-Qual: UnQual l (Name l)
  . Then instead of the Index, I have a unqualified Index directly from the
    config file.
  . Generate or modify unqualified import lines.
  . Config syntax:
    unqualified: System.FilePath.(</>) System.FilePath.takeFileName
  . I need the parens because import syntax requires them.  They correspond to
    Symbol Names.

- remove unused unqualified imports, possibly just the ones in the unqualified
list

* Synth.Sampler.Render gets Statistics.Sample instead of local
  Synth.Sampler.Sample
  . findModule Qualification "Sample": local ["Synth/Sampler/Sample.hs"]
    findModule Qualification "Sample":
      package [(Just "statistics",ModuleName "Statistics.Sample")]

* import-order-last: Synth.Lib.Global doesn't work
  . Maybe it just does first match, not most specific match?
  . Because order only expects toplevel name.
  . I can generalize to longest prefix match.
  . Supporting .Global means I could put Global modules at the end.
    Or I could say an unqualified import without a corresponding qualified one
    goes at the end?

* putting Data.Map in prio-module-high also makes everything under Data.Map
  high prio.  Then I get Data.Map.Internal.Debug over Util.Debug.
  . I could do exact matches, but say Synth. is a shorthand for
    (Synth|Synth\..*).
  . Actually why not just always do exact matches for prio-module?
    I think I did prefixes because I wanted 'prio-module-low: GHC' to not
    resolve any GHC.* modules.  But surely 'prio-package-low: ghc' handles
    that?

- Use a cabal sandbox if one is present.
- use stack if present
  . I think just:
    if [ $use_stack ]; then
        export GHC_PACKAGE_PATH=$(stack path --ghc-package-path)
        PATH=$(stack path --compiler-bin):$PATH
    fi

- haskell-src-exts is buggy.  Can I use the ghc parser yet?
  . ghc-parser package?
  . But I thought this was tied to the trees that grow changes?
  . ghc-syntax-highlighter - uses lexer?

/ Optionally write a cache of the package db.
  . No need, most time is spent in haskell-src-exts parsing.

- Use haskell-names to guess the module to import based on the function name:
  http://documentup.com/haskell-suite/haskell-names
  This could even potentially support unqualified imports.

/ Didn't want to import Ui.Types when I already have Types imported
unqualified.
  I think this is working as intended, because an unqualified import can also
  be used qualified.

* If I set Util.Map in prio-module-low or Data.Map in prio-module-high, why
does Util.Map still get imported?  It's because local modules are always
prioritized above package ones.  To fix this I could have a ad-hoc map of e.g.
'Map -> Data.Map' to manually set certain resolutions.
  . Or, why not just make local vs global only apply when not in
    prio-module-high or prio-module-low.
  . I think I just change the order in Config.prioritize.  Could it be that
    simple?

- If the choice is still ambiguous I could ask interactively.
  . This requires deeper integration, but vim does have menu selection
    support.

- Or write a simple tool to analyze existing code and assign priorities
  based on how often each is imported.
