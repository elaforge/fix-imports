* done; - not done; / decided against

bug:
  * warn about duplicate config entries
  - unqualified imports cause imports due to symbols not in call position
  * It wants to manage unqualified imports it shouldn't
    . if I have 'unqualified: Control.Monad.when', it will delete a
      'import Control.Monad (unless)'

feature:
  - use tags see what module exports what, and disambiguate modules
    . https://github.com/JonnyRa/vim-himposter
  - I'd like a add/removed symbol if it modified an unqualified import list
  * unqualified syntax sugar: Data.Bifunctor.(first, second)
    . Unfortunately this is ambiguous with operators: A.(+).
    . I could imitate import syntax: A (b); C ((+), d)
      But I need to separate with something, like ;.
  groq style:
    * space for qualified
    * import qualified as some other name, e.g.
      . import-as: Data.Text.Lazy as DTL, ...
    * disable automatic grouping, just [hackage, local]

  / add *all* possible imports, but comment out all but the priority one
    . This seems not great because much of the time it guesses right.
    . Then I need some notion of certainty.
    . Maybe only for local imports?  Or local imports where there isn't an
      obvious winner, where obvious winner means in the same directory?

  - Use a cabal sandbox if one is present.
  - use stack if present
    . I think just:
      if [ $use_stack ]; then
          export GHC_PACKAGE_PATH=$(stack path --ghc-package-path)
          PATH=$(stack path --compiler-bin):$PATH
      fi

  - haskell-src-exts is buggy.  Can I use the ghc parser yet?
    . ghc-lib-parser
    . ghc-parser package?
    . But I thought this was tied to the trees that grow changes?
    . ghc-syntax-highlighter - uses lexer?

  / Optionally write a cache of the package db.
    . No need, most time is spent in haskell-src-exts parsing.
    . Actually not really, but overall time is low.

  - Use haskell-names to guess the module to import based on the function name:
    http://documentup.com/haskell-suite/haskell-names
    This could even potentially support unqualified imports.

  / Didn't want to import Ui.Types when I already have Types imported
  unqualified.
    I think this is working as intended, because an unqualified import can also
    be used qualified.

  - If the choice is still ambiguous I could ask interactively.
    . This requires deeper integration, but vim does have menu selection
      support.

  - Or write a simple tool to analyze existing code and assign priorities
    based on how often each is imported.
